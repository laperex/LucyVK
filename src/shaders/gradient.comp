#version 460

//size of a workgroup for compute
layout (local_size_x = 4, local_size_y = 4) in;

//descriptor bindings for the pipeline
layout(rgba16f, set = 0, binding = 0) uniform image2D image;
layout(set = 0, binding = 1) uniform CameraBuffer {
	mat4 projection;
	mat4 view;
	mat4 model;
	vec4 color;
} cam_data;

#define MAX_STEPS 1000
#define MAX_DIST 100.0
#define SURF_DIST .01

float get_sdf(vec3 p) {
	vec4 s = vec4(0, 1, 6, 1);
	
	float sphere_dist = length(p-s.xyz) - s.w;
	float plane_dist = p.y;
	
	return min(sphere_dist, plane_dist);
}

float ray_march(vec3 ro, vec3 rd) {
	float d0 = 0.0;
	
	for (int i = 0; i < MAX_STEPS; i++) {
		vec3 p = ro + rd * d0;
		float dS = get_sdf(p);
		d0 += dS;
		if (d0 > MAX_DIST || dS < SURF_DIST) {
			break;
		}
	}
	
	return d0;
}

void main() 
{
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(image);

    // if (texelCoord.x < size.x && texelCoord.y < size.y)
    // {
    //     vec4 color = vec4(0.0, 0.0, 0.0, 0.0);

    //     if (gl_LocalInvocationID.x == 0 && gl_LocalInvocationID.y == 0)
    //     {
    //         color.x = float(texelCoord.x)/(size.x);
    //         color.y = float(texelCoord.y)/(size.y);	
    //     }
    // }
	vec4 color = vec4(0);
	
	vec2 uv = (texelCoord.xy - 0.5 * size.xy) / size.y;
	
	vec3 ray_origin = vec3(0, 1, 0);
	vec3 ray_dir = normalize(vec3(uv.x, uv.y, 1));

	float d = ray_march(ray_origin, ray_dir);
	
	d /= 6.0;
	
	color = vec4(d);
	
	imageStore(image, texelCoord, color);
}
